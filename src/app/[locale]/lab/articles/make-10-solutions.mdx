export const metadata = {
  title: "Brute forcing the Make 10 game",
  description: "A small project to brute-force the 'Make 10' puzzle for every 4-digit input (0000–9999). I describe the rules, the operations I allowed, and the solver's results",
  date: "2025-11-23",
  slug: "make-10-solutions",
};

import { Make10List } from "@/components/make-10-list";
import solutions from "../data/make-10-solutions.json";

I stumbled upon some YouTube or Instagram short lately, of someone trying to solve the **[Sydney Train Game](https://en.wikipedia.org/wiki/24_(puzzle))**. The premise is simple: take the four digits of the carriage number and combine them using basic arithmetic to reach 24. I toyed with a few examples, but most of them were very easy to solve. So I wanted something more challenging.

To make things more difficult, I switched the target number from 24 to **10**, that have fewer divisors, and limited myself to **ordered** operations (i.e., no reordering of the digits). I'm sure I'm not the first one to think of this variation, but I'll call it the "Make 10" game, for lack of a better name.

It teased my brain for a while, but, as a developer, of course I had to spend some time automating the solution.

The result is a brute-force solver that explores all possible combinations of operations to reach the target number of 10 for every possible 4-digit input (from `0000` to `9999`). Below, I describe the rules I set, the operations I allowed, and share the solver's results.

### The Rules

The target is always **10**.
The input is a 4-digit string.
Order is immutable.
You must use all four digits exactly once.

### The Operations

I wanted to keep the puzzle challenging yet solvable.

To respect the original spirit of the game, I limited myself to operations that can without a doubt be read left-to-right (that's why the division is written as a non-standard slash).

To make this interesting (and solvable), I had to expand the standard operator set. Standard arithmetic isn't enough to cover the search space, but I also didn't want to allow infinite complexity.

I allowed the following operations:

*   **Standard:** [Addition](https://en.wikipedia.org/wiki/Addition), [Subtraction](https://en.wikipedia.org/wiki/Subtraction), [Multiplication](https://en.wikipedia.org/wiki/Multiplication), [Division](https://en.wikipedia.org/wiki/Division).
*   **Exponents/Roots:** [Exponentiation](https://en.wikipedia.org/wiki/Exponentiation), [Square Root](https://en.wikipedia.org/wiki/Square_root), and [n-th Root](https://en.wikipedia.org/wiki/Nth_root).
*   **Functions:** [Logarithms](https://en.wikipedia.org/wiki/Logarithm), [Factorials](https://en.wikipedia.org/wiki/Factorial), [Modulus](https://en.wikipedia.org/wiki/Modulo_operation), and [Absolute Value](https://en.wikipedia.org/wiki/Absolute_value).
*   **The Triangular Operator:** I included the triangular number, symbolized here using Knuth’s notation as `?`. (e.g., `3?` = 6). You can read more about it [here](https://en.wikipedia.org/wiki/Triangular_number).

I'm aware that some of these operations (like factorials or logarithms) might feel a bit like "cheating" in the context of a simple arithmetic game. However, they add an interesting layer of complexity and open up more possibilities for reaching the target number. In my first attempts, I found that around 10% of the inputs were unsolvable with just basic arithmetic, so these additional operations were necessary to find solutions for a broader range of inputs.

Below is the full, exported list of solutions that the solver produced for every 4-digit input. The interactive list includes the simplest found expression for each input.

<Make10List solutions={solutions} />

### The Implementation

The code itself is nothing revolutionary. It’s a brute-force depth-first search that constructs an expression tree. The biggest challenge wasn't the math, but the constraints of the machine.

1.  **Termination:** Nesting factorials and triangular numbers leads to overflows very quickly. I had to cap the search depth aggressively to prevent the code from running until the heat death of the universe.
2.  **Formatting:** I spent an unreasonable amount of time fighting with LaTeX formatting to ensure the output didn't look like ASCII soup.
3.  **Heuristics:** I didn't just want *a* solution; I wanted the *simplest* one. I weighted the solver to prefer basic arithmetic (`+`, `-`) over "weapons of mass destruction" like the triangular operator or nested roots. It only pulls out the heavy artillery when absolutely necessary (or at least, that's what I tried).

Also, if you find some, I’d be happy to see simpler solutions that don't rely on the modulus operator (`mod`) or the triangular operator (`?`); please share any you find and I’ll incorporate them.
